"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./utils/websocket.js":
/*!****************************!*\
  !*** ./utils/websocket.js ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   connectWebSocket: function() { return /* binding */ connectWebSocket; },\n/* harmony export */   disconnectWebSocket: function() { return /* binding */ disconnectWebSocket; },\n/* harmony export */   emitEvent: function() { return /* binding */ emitEvent; },\n/* harmony export */   subscribeToEvent: function() { return /* binding */ subscribeToEvent; }\n/* harmony export */ });\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! socket.io-client */ \"./node_modules/socket.io-client/build/esm/index.js\");\n\n// 모의 데이터 사용 여부\nconst USE_MOCK_WEBSOCKET = true;\nlet socket = null;\nlet mockCallbacks = {};\nlet mockInterval = null;\n// 모의 이벤트 데이터\nconst mockEvents = {\n    \"trade_update\": [\n        {\n            id: 1001,\n            symbol: \"BTC/USDT\",\n            type: \"buy\",\n            price: 42150.25,\n            amount: 0.05,\n            timestamp: Date.now()\n        },\n        {\n            id: 1002,\n            symbol: \"ETH/USDT\",\n            type: \"sell\",\n            price: 2250.75,\n            amount: 0.8,\n            timestamp: Date.now()\n        },\n        {\n            id: 1003,\n            symbol: \"SOL/USDT\",\n            type: \"buy\",\n            price: 105.50,\n            amount: 10,\n            timestamp: Date.now()\n        }\n    ],\n    \"price_update\": [\n        {\n            symbol: \"BTC/USDT\",\n            price: 42150.25,\n            change: 1.2\n        },\n        {\n            symbol: \"ETH/USDT\",\n            price: 2250.75,\n            change: -0.5\n        },\n        {\n            symbol: \"BNB/USDT\",\n            price: 380.20,\n            change: 0.8\n        },\n        {\n            symbol: \"SOL/USDT\",\n            price: 105.50,\n            change: 2.3\n        },\n        {\n            symbol: \"XRP/USDT\",\n            price: 0.52,\n            change: -1.1\n        }\n    ],\n    \"bot_status\": [\n        {\n            status: \"running\",\n            mode: \"paper\",\n            active_trades: 2\n        },\n        {\n            status: \"paused\",\n            mode: \"paper\",\n            active_trades: 1\n        },\n        {\n            status: \"stopped\",\n            mode: \"paper\",\n            active_trades: 0\n        }\n    ],\n    \"portfolio_update\": [\n        {\n            balance: 10245.67,\n            equity: 10500.23,\n            profit_today: 125.45,\n            profit_today_percentage: 1.23\n        },\n        {\n            balance: 10300.42,\n            equity: 10550.18,\n            profit_today: 150.32,\n            profit_today_percentage: 1.45\n        },\n        {\n            balance: 10275.89,\n            equity: 10525.67,\n            profit_today: 135.78,\n            profit_today_percentage: 1.32\n        }\n    ]\n};\n// 모의 WebSocket 연결\nconst connectMockWebSocket = ()=>{\n    console.log(\"Mock WebSocket connected\");\n    // 이벤트 발생 시뮬레이션\n    mockInterval = setInterval(()=>{\n        // 각 이벤트 형식에 대해 랜덤하게 데이터 전송\n        Object.keys(mockEvents).forEach((eventName)=>{\n            if (mockCallbacks[eventName]) {\n                const eventData = mockEvents[eventName][Math.floor(Math.random() * mockEvents[eventName].length)];\n                // 타임스태프 업데이트\n                if (eventData.timestamp) {\n                    eventData.timestamp = Date.now();\n                }\n                mockCallbacks[eventName].forEach((callback)=>callback(eventData));\n            }\n        });\n    }, 5000); // 5초마다 이벤트 발생\n    return {\n        on: (event, callback)=>{\n            if (!mockCallbacks[event]) {\n                mockCallbacks[event] = [];\n            }\n            mockCallbacks[event].push(callback);\n        },\n        off: (event, callback)=>{\n            if (mockCallbacks[event]) {\n                mockCallbacks[event] = mockCallbacks[event].filter((cb)=>cb !== callback);\n            }\n        },\n        emit: (event, data)=>{\n            console.log(\"Mock WebSocket emit: \".concat(event), data);\n            // 서버로 이벤트 전송 시뮬레이션\n            setTimeout(()=>{\n                if (event === \"start_bot\") {\n                    if (mockCallbacks[\"bot_status\"]) {\n                        mockCallbacks[\"bot_status\"].forEach((callback)=>callback({\n                                status: \"running\",\n                                mode: \"paper\",\n                                active_trades: 0\n                            }));\n                    }\n                } else if (event === \"stop_bot\") {\n                    if (mockCallbacks[\"bot_status\"]) {\n                        mockCallbacks[\"bot_status\"].forEach((callback)=>callback({\n                                status: \"stopped\",\n                                mode: \"paper\",\n                                active_trades: 0\n                            }));\n                    }\n                } else if (event === \"pause_bot\") {\n                    if (mockCallbacks[\"bot_status\"]) {\n                        mockCallbacks[\"bot_status\"].forEach((callback)=>callback({\n                                status: \"paused\",\n                                mode: \"paper\",\n                                active_trades: 0\n                            }));\n                    }\n                }\n            }, 500);\n        },\n        disconnect: ()=>{\n            if (mockInterval) {\n                clearInterval(mockInterval);\n                mockInterval = null;\n            }\n            mockCallbacks = {};\n            console.log(\"Mock WebSocket disconnected\");\n        }\n    };\n};\nconst connectWebSocket = (token)=>{\n    if (socket) {\n        // 이미 연결된 경우 기존 소켓 반환\n        return socket;\n    }\n    // 모의 WebSocket 사용\n    if (USE_MOCK_WEBSOCKET) {\n        socket = connectMockWebSocket();\n        return socket;\n    }\n    // 실제 Socket.IO 연결 코드\n    const WS_URL = \"ws://localhost:8000\" || 0;\n    // Socket.IO 클라이언트 생성\n    socket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_0__.io)(WS_URL, {\n        auth: {\n            token\n        },\n        transports: [\n            \"websocket\"\n        ],\n        reconnection: true,\n        reconnectionAttempts: 5,\n        reconnectionDelay: 1000,\n        reconnectionDelayMax: 5000,\n        timeout: 20000\n    });\n    // 연결 이벤트 핸들러\n    socket.on(\"connect\", ()=>{\n        console.log(\"WebSocket connected\");\n    });\n    // 연결 오류 핸들러\n    socket.on(\"connect_error\", (error)=>{\n        console.error(\"WebSocket connection error:\", error);\n    });\n    // 재연결 시도 핸들러\n    socket.on(\"reconnect_attempt\", (attemptNumber)=>{\n        console.log(\"WebSocket reconnection attempt: \".concat(attemptNumber));\n    });\n    // 재연결 실패 핸들러\n    socket.on(\"reconnect_failed\", ()=>{\n        console.error(\"WebSocket reconnection failed\");\n    });\n    // 연결 해제 핸들러\n    socket.on(\"disconnect\", (reason)=>{\n        console.log(\"WebSocket disconnected: \".concat(reason));\n    });\n    return socket;\n};\nconst disconnectWebSocket = ()=>{\n    if (socket) {\n        socket.disconnect();\n        socket = null;\n        console.log(\"WebSocket disconnected\");\n    }\n};\nconst subscribeToEvent = (event, callback)=>{\n    if (!socket) {\n        console.error(\"WebSocket not connected\");\n        return;\n    }\n    socket.on(event, callback);\n    return ()=>socket.off(event, callback); // 구독 해제 함수 반환\n};\nconst emitEvent = (event, data)=>{\n    if (!socket) {\n        console.error(\"WebSocket not connected\");\n        return;\n    }\n    socket.emit(event, data);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0YsT0FBT0YsV0FBVyxjQUFjO0FBQzFELEVBQUU7QUFFSyxNQUFNNkIsWUFBWSxDQUFDM0IsT0FBT007SUFDL0IsSUFBSSxDQUFDekMsUUFBUTtRQUNYcUIsUUFBUW9DLEtBQUssQ0FBQztRQUNkO0lBQ0Y7SUFFQXpELE9BQU93QyxJQUFJLENBQUNMLE9BQU9NO0FBQ3JCLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvd2Vic29ja2V0LmpzP2Q4ZTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW8gfSBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcblxuLy8g66qo7J2YIOuNsOydtO2EsCDsgqzsmqkg7Jes67aAXG5jb25zdCBVU0VfTU9DS19XRUJTT0NLRVQgPSB0cnVlO1xuXG5sZXQgc29ja2V0ID0gbnVsbDtcbmxldCBtb2NrQ2FsbGJhY2tzID0ge307XG5sZXQgbW9ja0ludGVydmFsID0gbnVsbDtcblxuLy8g66qo7J2YIOydtOuypO2KuCDrjbDsnbTthLBcbmNvbnN0IG1vY2tFdmVudHMgPSB7XG4gICd0cmFkZV91cGRhdGUnOiBbXG4gICAgeyBpZDogMTAwMSwgc3ltYm9sOiAnQlRDL1VTRFQnLCB0eXBlOiAnYnV5JywgcHJpY2U6IDQyMTUwLjI1LCBhbW91bnQ6IDAuMDUsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9LFxuICAgIHsgaWQ6IDEwMDIsIHN5bWJvbDogJ0VUSC9VU0RUJywgdHlwZTogJ3NlbGwnLCBwcmljZTogMjI1MC43NSwgYW1vdW50OiAwLjgsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9LFxuICAgIHsgaWQ6IDEwMDMsIHN5bWJvbDogJ1NPTC9VU0RUJywgdHlwZTogJ2J1eScsIHByaWNlOiAxMDUuNTAsIGFtb3VudDogMTAsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9XG4gIF0sXG4gICdwcmljZV91cGRhdGUnOiBbXG4gICAgeyBzeW1ib2w6ICdCVEMvVVNEVCcsIHByaWNlOiA0MjE1MC4yNSwgY2hhbmdlOiAxLjIgfSxcbiAgICB7IHN5bWJvbDogJ0VUSC9VU0RUJywgcHJpY2U6IDIyNTAuNzUsIGNoYW5nZTogLTAuNSB9LFxuICAgIHsgc3ltYm9sOiAnQk5CL1VTRFQnLCBwcmljZTogMzgwLjIwLCBjaGFuZ2U6IDAuOCB9LFxuICAgIHsgc3ltYm9sOiAnU09ML1VTRFQnLCBwcmljZTogMTA1LjUwLCBjaGFuZ2U6IDIuMyB9LFxuICAgIHsgc3ltYm9sOiAnWFJQL1VTRFQnLCBwcmljZTogMC41MiwgY2hhbmdlOiAtMS4xIH1cbiAgXSxcbiAgJ2JvdF9zdGF0dXMnOiBbXG4gICAgeyBzdGF0dXM6ICdydW5uaW5nJywgbW9kZTogJ3BhcGVyJywgYWN0aXZlX3RyYWRlczogMiB9LFxuICAgIHsgc3RhdHVzOiAncGF1c2VkJywgbW9kZTogJ3BhcGVyJywgYWN0aXZlX3RyYWRlczogMSB9LFxuICAgIHsgc3RhdHVzOiAnc3RvcHBlZCcsIG1vZGU6ICdwYXBlcicsIGFjdGl2ZV90cmFkZXM6IDAgfVxuICBdLFxuICAncG9ydGZvbGlvX3VwZGF0ZSc6IFtcbiAgICB7IGJhbGFuY2U6IDEwMjQ1LjY3LCBlcXVpdHk6IDEwNTAwLjIzLCBwcm9maXRfdG9kYXk6IDEyNS40NSwgcHJvZml0X3RvZGF5X3BlcmNlbnRhZ2U6IDEuMjMgfSxcbiAgICB7IGJhbGFuY2U6IDEwMzAwLjQyLCBlcXVpdHk6IDEwNTUwLjE4LCBwcm9maXRfdG9kYXk6IDE1MC4zMiwgcHJvZml0X3RvZGF5X3BlcmNlbnRhZ2U6IDEuNDUgfSxcbiAgICB7IGJhbGFuY2U6IDEwMjc1Ljg5LCBlcXVpdHk6IDEwNTI1LjY3LCBwcm9maXRfdG9kYXk6IDEzNS43OCwgcHJvZml0X3RvZGF5X3BlcmNlbnRhZ2U6IDEuMzIgfVxuICBdXG59O1xuXG4vLyDrqqjsnZggV2ViU29ja2V0IOyXsOqysFxuY29uc3QgY29ubmVjdE1vY2tXZWJTb2NrZXQgPSAoKSA9PiB7XG4gIGNvbnNvbGUubG9nKCdNb2NrIFdlYlNvY2tldCBjb25uZWN0ZWQnKTtcbiAgXG4gIC8vIOydtOuypO2KuCDrsJzsg50g7Iuc666s66CI7J207IWYXG4gIG1vY2tJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAvLyDqsIEg7J2067Kk7Yq4IO2YleyLneyXkCDrjIDtlbQg656c642k7ZWY6rKMIOuNsOydtO2EsCDsoITshqFcbiAgICBPYmplY3Qua2V5cyhtb2NrRXZlbnRzKS5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICBpZiAobW9ja0NhbGxiYWNrc1tldmVudE5hbWVdKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IG1vY2tFdmVudHNbZXZlbnROYW1lXVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtb2NrRXZlbnRzW2V2ZW50TmFtZV0ubGVuZ3RoKV07XG4gICAgICAgIC8vIO2DgOyehOyKpO2DnO2UhCDsl4XrjbDsnbTtirhcbiAgICAgICAgaWYgKGV2ZW50RGF0YS50aW1lc3RhbXApIHtcbiAgICAgICAgICBldmVudERhdGEudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICBtb2NrQ2FsbGJhY2tzW2V2ZW50TmFtZV0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhldmVudERhdGEpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgNTAwMCk7IC8vIDXstIjrp4jri6Qg7J2067Kk7Yq4IOuwnOyDnVxuICBcbiAgcmV0dXJuIHtcbiAgICBvbjogKGV2ZW50LCBjYWxsYmFjaykgPT4ge1xuICAgICAgaWYgKCFtb2NrQ2FsbGJhY2tzW2V2ZW50XSkge1xuICAgICAgICBtb2NrQ2FsbGJhY2tzW2V2ZW50XSA9IFtdO1xuICAgICAgfVxuICAgICAgbW9ja0NhbGxiYWNrc1tldmVudF0ucHVzaChjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvZmY6IChldmVudCwgY2FsbGJhY2spID0+IHtcbiAgICAgIGlmIChtb2NrQ2FsbGJhY2tzW2V2ZW50XSkge1xuICAgICAgICBtb2NrQ2FsbGJhY2tzW2V2ZW50XSA9IG1vY2tDYWxsYmFja3NbZXZlbnRdLmZpbHRlcihjYiA9PiBjYiAhPT0gY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW1pdDogKGV2ZW50LCBkYXRhKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhgTW9jayBXZWJTb2NrZXQgZW1pdDogJHtldmVudH1gLCBkYXRhKTtcbiAgICAgIC8vIOyEnOuyhOuhnCDsnbTrsqTtirgg7KCE7IahIOyLnOuurOugiOydtOyFmFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChldmVudCA9PT0gJ3N0YXJ0X2JvdCcpIHtcbiAgICAgICAgICBpZiAobW9ja0NhbGxiYWNrc1snYm90X3N0YXR1cyddKSB7XG4gICAgICAgICAgICBtb2NrQ2FsbGJhY2tzWydib3Rfc3RhdHVzJ10uZm9yRWFjaChjYWxsYmFjayA9PiBcbiAgICAgICAgICAgICAgY2FsbGJhY2soeyBzdGF0dXM6ICdydW5uaW5nJywgbW9kZTogJ3BhcGVyJywgYWN0aXZlX3RyYWRlczogMCB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09ICdzdG9wX2JvdCcpIHtcbiAgICAgICAgICBpZiAobW9ja0NhbGxiYWNrc1snYm90X3N0YXR1cyddKSB7XG4gICAgICAgICAgICBtb2NrQ2FsbGJhY2tzWydib3Rfc3RhdHVzJ10uZm9yRWFjaChjYWxsYmFjayA9PiBcbiAgICAgICAgICAgICAgY2FsbGJhY2soeyBzdGF0dXM6ICdzdG9wcGVkJywgbW9kZTogJ3BhcGVyJywgYWN0aXZlX3RyYWRlczogMCB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQgPT09ICdwYXVzZV9ib3QnKSB7XG4gICAgICAgICAgaWYgKG1vY2tDYWxsYmFja3NbJ2JvdF9zdGF0dXMnXSkge1xuICAgICAgICAgICAgbW9ja0NhbGxiYWNrc1snYm90X3N0YXR1cyddLmZvckVhY2goY2FsbGJhY2sgPT4gXG4gICAgICAgICAgICAgIGNhbGxiYWNrKHsgc3RhdHVzOiAncGF1c2VkJywgbW9kZTogJ3BhcGVyJywgYWN0aXZlX3RyYWRlczogMCB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIDUwMCk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0OiAoKSA9PiB7XG4gICAgICBpZiAobW9ja0ludGVydmFsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwobW9ja0ludGVydmFsKTtcbiAgICAgICAgbW9ja0ludGVydmFsID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIG1vY2tDYWxsYmFja3MgPSB7fTtcbiAgICAgIGNvbnNvbGUubG9nKCdNb2NrIFdlYlNvY2tldCBkaXNjb25uZWN0ZWQnKTtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY29ubmVjdFdlYlNvY2tldCA9ICh0b2tlbikgPT4ge1xuICBpZiAoc29ja2V0KSB7XG4gICAgLy8g7J2066+4IOyXsOqysOuQnCDqsr3smrAg6riw7KG0IOyGjOy8kyDrsJjtmZhcbiAgICByZXR1cm4gc29ja2V0O1xuICB9XG5cbiAgLy8g66qo7J2YIFdlYlNvY2tldCDsgqzsmqlcbiAgaWYgKFVTRV9NT0NLX1dFQlNPQ0tFVCkge1xuICAgIHNvY2tldCA9IGNvbm5lY3RNb2NrV2ViU29ja2V0KCk7XG4gICAgcmV0dXJuIHNvY2tldDtcbiAgfVxuXG4gIC8vIOyLpOygnCBTb2NrZXQuSU8g7Jew6rKwIOy9lOuTnFxuICBjb25zdCBXU19VUkwgPSBwcm9jZXNzLmVudi5XU19VUkwgfHwgJ3dzOi8vbG9jYWxob3N0OjgwMDAnO1xuICBcbiAgLy8gU29ja2V0LklPIO2BtOudvOydtOyWuO2KuCDsg53shLFcbiAgc29ja2V0ID0gaW8oV1NfVVJMLCB7XG4gICAgYXV0aDoge1xuICAgICAgdG9rZW5cbiAgICB9LFxuICAgIHRyYW5zcG9ydHM6IFsnd2Vic29ja2V0J10sXG4gICAgcmVjb25uZWN0aW9uOiB0cnVlLFxuICAgIHJlY29ubmVjdGlvbkF0dGVtcHRzOiA1LFxuICAgIHJlY29ubmVjdGlvbkRlbGF5OiAxMDAwLFxuICAgIHJlY29ubmVjdGlvbkRlbGF5TWF4OiA1MDAwLFxuICAgIHRpbWVvdXQ6IDIwMDAwXG4gIH0pO1xuXG4gIC8vIOyXsOqysCDsnbTrsqTtirgg7ZW465Ok65+sXG4gIHNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnV2ViU29ja2V0IGNvbm5lY3RlZCcpO1xuICB9KTtcblxuICAvLyDsl7DqsrAg7Jik66WYIO2VuOuTpOufrFxuICBzb2NrZXQub24oJ2Nvbm5lY3RfZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKCdXZWJTb2NrZXQgY29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gIH0pO1xuXG4gIC8vIOyerOyXsOqysCDsi5zrj4Qg7ZW465Ok65+sXG4gIHNvY2tldC5vbigncmVjb25uZWN0X2F0dGVtcHQnLCAoYXR0ZW1wdE51bWJlcikgPT4ge1xuICAgIGNvbnNvbGUubG9nKGBXZWJTb2NrZXQgcmVjb25uZWN0aW9uIGF0dGVtcHQ6ICR7YXR0ZW1wdE51bWJlcn1gKTtcbiAgfSk7XG5cbiAgLy8g7J6s7Jew6rKwIOyLpO2MqCDtlbjrk6Trn6xcbiAgc29ja2V0Lm9uKCdyZWNvbm5lY3RfZmFpbGVkJywgKCkgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1dlYlNvY2tldCByZWNvbm5lY3Rpb24gZmFpbGVkJyk7XG4gIH0pO1xuXG4gIC8vIOyXsOqysCDtlbTsoJwg7ZW465Ok65+sXG4gIHNvY2tldC5vbignZGlzY29ubmVjdCcsIChyZWFzb24pID0+IHtcbiAgICBjb25zb2xlLmxvZyhgV2ViU29ja2V0IGRpc2Nvbm5lY3RlZDogJHtyZWFzb259YCk7XG4gIH0pO1xuXG4gIHJldHVybiBzb2NrZXQ7XG59O1xuXG5leHBvcnQgY29uc3QgZGlzY29ubmVjdFdlYlNvY2tldCA9ICgpID0+IHtcbiAgaWYgKHNvY2tldCkge1xuICAgIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgc29ja2V0ID0gbnVsbDtcbiAgICBjb25zb2xlLmxvZygnV2ViU29ja2V0IGRpc2Nvbm5lY3RlZCcpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3Qgc3Vic2NyaWJlVG9FdmVudCA9IChldmVudCwgY2FsbGJhY2spID0+IHtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBjb25zb2xlLmVycm9yKCdXZWJTb2NrZXQgbm90IGNvbm5lY3RlZCcpO1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgc29ja2V0Lm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gIHJldHVybiAoKSA9PiBzb2NrZXQub2ZmKGV2ZW50LCBjYWxsYmFjayk7IC8vIOq1rOuPhSDtlbTsoJwg7ZWo7IiYIOuwmO2ZmFxufTtcblxuZXhwb3J0IGNvbnN0IGVtaXRFdmVudCA9IChldmVudCwgZGF0YSkgPT4ge1xuICBpZiAoIXNvY2tldCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1dlYlNvY2tldCBub3QgY29ubmVjdGVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICBzb2NrZXQuZW1pdChldmVudCwgZGF0YSk7XG59O1xuIl0sIm5hbWVzIjpbImlvIiwiVVNFX01PQ0tfV0VCU09DS0VUIiwic29ja2V0IiwibW9ja0NhbGxiYWNrcyIsIm1vY2tJbnRlcnZhbCIsIm1vY2tFdmVudHMiLCJpZCIsInN5bWJvbCIsInR5cGUiLCJwcmljZSIsImFtb3VudCIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJjaGFuZ2UiLCJzdGF0dXMiLCJtb2RlIiwiYWN0aXZlX3RyYWRlcyIsImJhbGFuY2UiLCJlcXVpdHkiLCJwcm9maXRfdG9kYXkiLCJwcm9maXRfdG9kYXlfcGVyY2VudGFnZSIsImNvbm5lY3RNb2NrV2ViU29ja2V0IiwiY29uc29sZSIsImxvZyIsInNldEludGVydmFsIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJldmVudE5hbWUiLCJldmVudERhdGEiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJsZW5ndGgiLCJjYWxsYmFjayIsIm9uIiwiZXZlbnQiLCJwdXNoIiwib2ZmIiwiZmlsdGVyIiwiY2IiLCJlbWl0IiwiZGF0YSIsInNldFRpbWVvdXQiLCJkaXNjb25uZWN0IiwiY2xlYXJJbnRlcnZhbCIsImNvbm5lY3RXZWJTb2NrZXQiLCJ0b2tlbiIsIldTX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJhdXRoIiwidHJhbnNwb3J0cyIsInJlY29ubmVjdGlvbiIsInJlY29ubmVjdGlvbkF0dGVtcHRzIiwicmVjb25uZWN0aW9uRGVsYXkiLCJyZWNvbm5lY3Rpb25EZWxheU1heCIsInRpbWVvdXQiLCJlcnJvciIsImF0dGVtcHROdW1iZXIiLCJyZWFzb24iLCJkaXNjb25uZWN0V2ViU29ja2V0Iiwic3Vic2NyaWJlVG9FdmVudCIsImVtaXRFdmVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/websocket.js\n"));

/***/ })

});